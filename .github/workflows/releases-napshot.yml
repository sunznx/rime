name: Build release branch snapshot

on:
  workflow_dispatch: # 手动触发
  push:
    branches:
      - wanxiang

concurrency:
  group: release-branch
  cancel-in-progress: true

jobs:
  build-release:
    runs-on: ubuntu-22.04

    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.x"

      - name: Release build
        run: bash .github/workflows/scripts/release-build.sh

      # 1. 用 dist/ 里的产物拼出 snapshot 目录
      - name: Prepare snapshot tree from dist
        run: |
          set -euo pipefail

          rm -rf snapshot
          mkdir -p snapshot

          # 使用 dist/ 里的目录构建 snapshot
          if ls dist/rime-wanxiang-* 1> /dev/null 2>&1; then
            for d in dist/rime-wanxiang-*; do
              [ -d "$d" ] || continue
              name="$(basename "$d")"
              echo "Copying directory $d -> snapshot/$name"
              mkdir -p "snapshot/$name"
              cp -a "$d"/. "snapshot/$name"/
            done
          else
            echo "Error: no dist/rime-wanxiang-* directories found."
            exit 1
          fi

          echo "Snapshot tree after prepare:"
          ls -R snapshot || true

      # 2. 在 snapshot/plum/ 目录下写所有东风破配方
      - name: Write plum recipes for wanxiang
        run: |
          set -euo pipefail
          mkdir -p snapshot/plum

          # 定义共用的文件列表模板（相对于“方案目录”的路径）
          COMMON_FILES="dicts/*.*
          opencc/*.*
          custom/*.*
          lua/*.*
          lua/lib/*.*
          lua/tips/*.*
          default.yaml
          weasel.yaml
          wanxiang*.yaml
          README.md
          简纯+.trime.yaml
          custom_phrase.txt"

          # 定义配方生成函数
          generate_recipe() {
            local rx_name="$1"
            local description="$2"
            local install_files="$3"
            
            cat > "snapshot/plum/${rx_name}.recipe.yaml" << EOF
          # encoding: utf-8
          ---
          recipe:
            Rx: plum/${rx_name}
            args:
            description: ${description}
          install_files: >-
          ${install_files}
          EOF
          }

          # 定义方案列表（对应 rime-wanxiang-<scheme> 目录）
          schemes=("base" "shouyou-fuzhu" "zrm-fuzhu" "tiger-fuzhu" "moqi-fuzhu" "flypy-fuzhu" "wubi-fuzhu" "hanxin-fuzhu")

          # 为每个方案生成配方
          for scheme in "${schemes[@]}"; do
            # 每个方案自己的目录前缀
            scheme_dir="rime-wanxiang-${scheme}"

            # 1) 完整版：COMMON_FILES 前面加上方案目录
            scheme_files="$(printf '%s\n' "$COMMON_FILES" | sed "s#^#  ${scheme_dir}/#")"

            generate_recipe "wanxiang-${scheme}-full" \
              "万象拼音：${scheme}版（整个方案目录）" \
              "$scheme_files"
            
            # 2) 仅词库：dicts 前面也加上方案目录
            generate_recipe "wanxiang-${scheme}-dicts" \
              "万象拼音：${scheme}版，仅词库（dicts-only）" \
              "  ${scheme_dir}/dicts/*.*"
          done

          echo "生成的配方文件："
          ls -la snapshot/plum/

      # 2.5 检查这次提交是否修改了 dicts 相关文件
      - name: Check if dicts changed
        id: dicts_changed
        run: |
          set -euo pipefail

          # 手动触发（workflow_dispatch）直接视为「有变动」，强制跑
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # 找到上一条提交（第一次提交可能没有 HEAD^，单独处理）
          if git rev-parse HEAD^ >/dev/null 2>&1; then
            RANGE="HEAD^ HEAD"
          else
            echo "Only one commit, treat as changed."
            echo "changed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # 检查本次改动的文件里有没有命中 dicts 目录
          if git diff --name-only $RANGE | grep -E '(^dicts/|^rime-wanxiang-.*/dicts/)' >/dev/null 2>&1; then
            echo "dicts changed."
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "dicts not changed."
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

      # 3. 从 dist 中打出每夜词库 zip（不套文件夹，只打 dicts/**）
      - name: Pack nightly dict zips
        if: steps.dicts_changed.outputs.changed == 'true'
        run: |
          set -euo pipefail

          mkdir -p dist

          pack_dict() {
            local src="$1"
            local zip_name="$2"
            if [[ -d "$src" ]]; then
              echo "Packing $src -> dist/${zip_name}"
              (cd "$src" && zip -r -q "../../${zip_name}" .)
            else
              echo "Warning: $src does not exist, skipped."
            fi
          }

          pack_dict "dist/rime-wanxiang-moqi-fuzhu/dicts"   "pro-moqi-fuzhu-dicts.zip"
          pack_dict "dist/rime-wanxiang-flypy-fuzhu/dicts"  "pro-flypy-fuzhu-dicts.zip"
          pack_dict "dist/rime-wanxiang-zrm-fuzhu/dicts"    "pro-zrm-fuzhu-dicts.zip"
          pack_dict "dist/rime-wanxiang-tiger-fuzhu/dicts"  "pro-tiger-fuzhu-dicts.zip"
          pack_dict "dist/rime-wanxiang-wubi-fuzhu/dicts"   "pro-wubi-fuzhu-dicts.zip"
          pack_dict "dist/rime-wanxiang-hanxin-fuzhu/dicts" "pro-hanxin-fuzhu-dicts.zip"
          pack_dict "dist/rime-wanxiang-shouyou-fuzhu/dicts" "pro-shouyou-fuzhu-dicts.zip"
          pack_dict "dist/rime-wanxiang-base/dicts"         "base-dicts.zip"

          echo "Nightly dict zips in dist/:"
          ls -1 dist/*.zip || true

      # 4. 删除旧的 Nightly Release 和 Tag
      - name: Delete existing Nightly Release and Tag
        if: steps.dicts_changed.outputs.changed == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const tag = "dict-nightly";
            try {
              const releases = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              const existingRelease = releases.data.find(r => r.tag_name === tag);
              if (existingRelease) {
                console.log(`Deleting existing Release with ID: ${existingRelease.id}`);
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: existingRelease.id
                });
              }

              console.log(`Deleting tag: ${tag}`);
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `tags/${tag}`
              });
            } catch (error) {
              console.log(`Error deleting Release or Tag: ${error.message}`);
            }

      - name: Wait for cleanup
        run: sleep 10

      # 5. 创建新的 Nightly Release，上传词库 zips
      - name: Create dict-nightly Release
        if: steps.dicts_changed.outputs.changed == 'true'
        uses: softprops/action-gh-release@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          tag_name: dict-nightly
          name: "实时提交的词库更新"
          body: |
            - **base-dicts.zip**：最新的标准版原始中文词库文件
            - **pro-moqi-fuzhu-dicts.zip**：携带了墨奇辅助码的词库文件
            - **pro-flypy-fuzhu-dicts.zip**：携带了小鹤辅助码的词库文件
            - **pro-zrm-fuzhu-dicts.zip**：携带了自然码辅助码的词库文件
            - **pro-tiger-fuzhu-dicts.zip**：携带了虎码辅助码的词库文件
            - **pro-wubi-fuzhu-dicts.zip**：携带了五笔辅助码的词库文件
            - **pro-hanxin-fuzhu-dicts.zip**：携带了汉心辅助码的词库文件
            - **pro-shouyou-fuzhu-dicts.zip**：携带了首右辅助码的词库文件
            - **[wanxiang-lts-zh-hans.gram](https://github.com/amzxyz/RIME-LMDG/releases/download/LTS/wanxiang-lts-zh-hans.gram)**：与词库同步更新的语法模型
          files: |
            dist/pro-moqi-fuzhu-dicts.zip
            dist/pro-flypy-fuzhu-dicts.zip
            dist/pro-zrm-fuzhu-dicts.zip
            dist/pro-tiger-fuzhu-dicts.zip
            dist/pro-wubi-fuzhu-dicts.zip
            dist/pro-hanxin-fuzhu-dicts.zip
            dist/pro-shouyou-fuzhu-dicts.zip
            dist/base-dicts.zip
          draft: false
          prerelease: false
          make_latest: true
      # 6. 切到 release 分支，用 snapshot 覆盖根目录并强推
      - name: Commit and force push release
        env:
          GIT_AUTHOR_NAME: ci-bot
          GIT_AUTHOR_EMAIL: ci@example.com
          GIT_COMMITTER_NAME: ci-bot
          GIT_COMMITTER_EMAIL: ci@example.com
        run: |
          set -euo pipefail

          # 先检查 release 分支是否存在
          if git show-ref --verify --quiet refs/heads/release; then
            git checkout release
          else
            git checkout --orphan release
          fi

          # 清空当前工作区（仅保留 .git 和 snapshot）
          find . -mindepth 1 -maxdepth 1 ! -name ".git" ! -name "snapshot" -exec rm -rf {} +

          # 把 snapshot 里的内容拷到根目录
          cp -a snapshot/. .

          # 不要把 snapshot 目录本身提交进去
          rm -rf snapshot

          git status

          tag_name="${{ github.event_name == 'release' && github.event.release.tag_name || 'manual-build' }}"

          git add .
          git commit -m "chore(release-branch): snapshot for ${tag_name}" \
            || echo "Nothing to commit."

          git push -f origin release